package com.inventory.myentity;

public class DistanceCalculator {
	private static final int EARTH_RADIUS = 6371; // Approx Earth radius in KM

	public static double calculateDistance(double startLat, double startLong, double endLat, double endLong) {
		 double a = 6378137.0;  // Semi-major axis of the Earth
		   double f = 1 / 298.257223563;  // Flattening of the Earth
		   double b = (1 - f) * a;
		   double U1 = Math.atan((1 - f) * Math.tan(Math.toRadians(startLat)));
		   double U2 = Math.atan((1 - f) * Math.tan(Math.toRadians(endLat)));
		   double L = Math.toRadians(endLong - startLong);
		   double lambda = L;
		   double lambdaP;
		   int iterLimit = 100;
		   double cosSqAlpha, sinSigma, cos2SigmaM, cosSigma, sigma;
		   double sinLambda=0, cosLambda=0, sinU1=0, sinU2=0, cosU1 = 0, cosU2 = 0;
		   do {
		       sinLambda = Math.sin(lambda);
		       cosLambda = Math.cos(lambda);
		       sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda) +
		                            (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) *
		                            (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
		       if (sinSigma == 0) return 0;  // co-incident points
		       cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
		       sigma = Math.atan2(sinSigma, cosSigma);
		       double sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
		       cosSqAlpha = 1 - sinAlpha * sinAlpha;
		       cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;
		       double C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
		       lambdaP = lambda;
		       lambda = L + (1 - C) * f * sinAlpha *
		                    (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma *
		                    (-1 + 2 * cos2SigmaM * cos2SigmaM)));
		   } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);
		   if (iterLimit == 0) return Double.NaN;  // formula failed to converge
		   double uSq = cosSqAlpha * (a * a - b * b) / (b * b);
		   double A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
		   double B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
		   double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 *
		                                       (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) -
		                                        B / 6 * cos2SigmaM *
		                                        (-3 + 4 * sinSigma * sinSigma) *
		                                        (-3 + 4 * cos2SigmaM * cos2SigmaM)));
		   double s = b * A * (sigma - deltaSigma);
		   return s / 1000; // returns distance in kilometers
	}
}
